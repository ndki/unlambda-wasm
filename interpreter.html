<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<style>
.main_container {
    display: flex;
}
.right {
    vertical-align: top;
    display: inline-block;
    font-family: sans-serif;
    font-size: 12px;
    white-space: pre-wrap;
}
</style>
<script>
'use strict;'
let Unlambda = class {
    parse (source) {
        let ast = new UnlambdaAST ();
        let node_stack = [ast.top];
        const READ = 0;
        const CHAR = 1;
        const CMMT = 2;
        let state = READ;
        let node = new UnlambdaASTNode ();
        for (let c of source) {
            if (state == READ && c.match(/\S/)) {
                const char_map = {
                    '`': UnlambdaASTApply,
                    'e': UnlambdaASTExit,
                    's': UnlambdaASTSubstitute,
                    'k': UnlambdaASTConstant,
                    'i': UnlambdaASTIdentity,
                    'v': UnlambdaASTVoid,
                    'd': UnlambdaASTDelay,
                    'c': UnlambdaASTCallCC,
                };
                let type = char_map[c];
                if (type === undefined) {
                    if (c == '.') {
                        node = new UnlambdaASTChar ();
                        state = CHAR;
                    } else if (c == 'r') {
                        node = new UnlambdaASTChar ();
                        node.value = "\n";
                    } else if (c == '#') {
                        state = CMMT;
                    } else {
                        throw 'Parse error: Unrecognized character '+c+'.'
                    }
                } else {
                    node = new char_map[c] ();
                }
                if (node.id != '!') {
                    let next = node_stack.pop().add(node);
                    if (next !== undefined) node_stack.push(...next);
                }
            } else if (state == CHAR) {
                node.value = c;
                state = READ;
            } else if (state == CMMT) {
                if (c == "\n") state = READ;
            }
        }
        return ast;
    }
    run () {
    }
}
let UnlambdaAST = class {
    top;
    constructor () {
        this.top = new UnlambdaASTTop ();
    }
    toString () {
        return ''+this.top;
    }
    compile () {
        return new UnlambdaExecutable (this);
    }
}
let UnlambdaASTNode = class {
    get name () { return 'empty' }
    get data () { return false }
    get id () { return '!' }
    static toString () {
        return '[empty]';
    }
    toString () {
        return '['+this.name+']';
    }
}
let UnlambdaASTTop = class {
    get name () { return 'top' }
    get data () { return true }
    list = [];
    add (node) {
        this.list.push(node);
        if (node.data) {
            return [this, node];
        } else {
            return [this];
        }
    }
    toString () {
        return 'AST(' + this.list.join(', ') + ')';
    }
}
let UnlambdaASTApply = class extends UnlambdaASTNode {
    get name () { return 'apply' }
    get data () { return true }
    get id () { return '`' }
    left = new UnlambdaASTNode ();
    right = new UnlambdaASTNode ();
    add (node) {
        if (this.left.id == '!') {
            this.left = node;
            if (node.data) {
                return [this, node];
            } else {
                return [this];
            }
        } else if (this.right.id == '!') {
            this.right = node;
            if (node.data) {
                return [node];
            } else {
                return [];
            }
        } else {
            throw 'Internal parser error: Full apply added to.';
        }
    }
    toString () {
        return '`(' + this.left + ' ' + this.right + ')';
    }
}
let UnlambdaASTConstant = class extends UnlambdaASTNode {
    get name () { return 'const' }
    get id () { return 'k' }
}
let UnlambdaASTSubstitute = class extends UnlambdaASTNode {
    get name () { return 'sub' }
    get id () { return 's' }
}
let UnlambdaASTIdentity = class extends UnlambdaASTNode {
    get name () { return 'id' }
    get id () { return 'i' }
}
let UnlambdaASTVoid = class extends UnlambdaASTNode {
    get name () { return 'void' }
    get id () { return 'v' }
}
let UnlambdaASTCallCC = class extends UnlambdaASTNode {
    get name () { return 'call/cc' }
    get id () { return 'c' }
}
let UnlambdaASTDelay = class extends UnlambdaASTNode {
    get name () { return 'delay' }
    get id () { return 'd' }
}
let UnlambdaASTExit = class extends UnlambdaASTNode {
    get name () { return 'exit' }
    get id () { return 'e' }
}
let UnlambdaASTChar = class extends UnlambdaASTNode {
    get name () { return 'char' }
    get id () { return '.' }
    value = '';
    toString () {
        return '[char ' + this.value + ']';
    }
}

let ExecData = class {
    toString () { return 'DATA' }
}
let ExecId = class {
    id;
    constructor (id) { this.id = id }
    toString () { return '['+this.id+']' }
}
let ExecCall = class {
    id = ExecId;
    constructor (id) { this.id = id }
    toString () { return 'P' + this.id }
}
let ExecValue = class {
    id = ExecId;
    constructor (id) { this.id = id }
    toString () { return 'V' + this.id }
}
let ExecVoid = class {
    toString () { return 'v' }
}
let ExecIdentity = class {
    toString () { return 'i' }
}
let ExecDelay = class {
    toString () { return 'd' }
}
let ExecPromise = class {
    constructor (v) { this.value = v }
    toString () { return 'd'+this.value }
}
let ExecConstant = class {
    toString () { return 'k' }
}
let ExecConstant1 = class {
    constructor (v) { this.value = v }
    toString () { return 'k'+this.value }
}
let ExecSubstitute = class {
    toString () { return 's' }
}
let ExecSubstitute1 = class {
    constructor (x) { this.x = x }
    toString () { return 's'+this.x }
}
let ExecSubstitute2 = class {
    constructor (x,y) { this.x = x; this.y = y }
    toString () { return 's'+this.x+this.y }
}
let ExecCallCC = class {
    toString () { return 'c' }
}
let ExecCC = class {
    constructor (id, cont) { this.id = id; this.continuation = cont }
    toString () { return '*' }
}
let ExecExit = class {
    toString () { return 'e' }
}
let ExecChar = class {
    constructor (v) { this.value = v }
    toString () { return 'C'+this.value }
}
let ExecCallStack = class {
    locations;
    status;
    constructor (locations=[], status=[]) {
        this.locations = locations;
        this.status = status;
    }
    get length () { return this.locations.length }
    clone () {
        // we will need to increase reference counts here
        return new this.constructor (
            this.locations.slice(0),
            this.status.slice(0)
        );
    }
    pop () {
        return [this.locations.pop(), this.status.pop()]
    }
    append (cs) {
        this.locations.push(...cs.locations);
        this.status.push(...cs.status);
    }
    unshift (new_l, new_s) {
        this.locations.unshift(new_l);
        this.status.unshift(new_s);
    }
    push (new_l, new_s) {
        this.locations.push(new_l);
        this.status.push(new_s);
    }
    toString () {
        const message = ['Fresh', 'Partial', 'Complete'];
        let s = "Continuation:\n";
        for (let i = this.length-1; i >= 0; i--) {
            s += message[this.status[i]]
                +' call at P'+this.locations[i]+"\n";
        }
        return s;
    }
}

let ExecIdGen = class {
    i = 0;
    next () { return new ExecId (this.i++) }
}

let ExecSeq = class {
    map = new Map ();
    set (a, b) { return this.map.set(a.id,b) }
    get (a) { return this.map.get(a.id) }
    toString () {
        let s = [...this.map.values()].join(', ');
        return s;
    }
    toStringW (id) {
        let s = [...this.map.keys()].map((k) =>{
            return id.id == k ? '['+this.map.get(k)+']' : this.map.get(k)
        }).join(', ');
        return s;
    }
}

let ExecRegister = class {
    map = new Map ();
    set (a, b) { return this.map.set(a.id,b) }
    get (a) { return this.map.get(a.id) }
}

const AST2Exec = {
    '.': ExecChar,
    'k': ExecConstant,
    'i': ExecIdentity,
    'v': ExecVoid,
    'd': ExecDelay,
    'c': ExecCallCC,
    's': ExecSubstitute,
    'e': ExecExit,
};

let UnlambdaExecutable = class {
    seq = new ExecSeq ();
    inits = [];
    r_id_gen = new ExecIdGen ();
    constructor (ast) {
        this.compile(ast);
    }
    compile (ast) {
        this.seq = new ExecSeq ();
        this.r_id_gen = new ExecIdGen ();
        this.inits = [];
        for (let node of ast.top.list) {
            if (node instanceof UnlambdaASTApply) {
                this.inits.push(this.compile_node(node));
            }
        }
    }
    compile_node (node) {
        let id = this.r_id_gen.next();
        let init = void 8;
        let node_stack = [[node, id, void 8, void 8]];
        let from_stack = false;
        let left_id; let right_id;
        while (node_stack.length > 0) {
            [node, id, left_id, right_id] = node_stack.pop();
            let left_valid = node.left.id != '!';
            let right_valid = node.right.id != '!';
            let left_apply = node.left.id == '`';
            let right_apply = node.right.id == '`';
            if (!init && left_valid && right_valid) {
                init = id;
            }
            if (left_apply && left_id === undefined){
                let next_i = this.r_id_gen.next();
                node_stack.push([node, id, next_i, void 8]);
                node_stack.push([node.left, next_i, void 8, void 8]);
                node = node.left;
            } else if (right_apply && right_id === undefined){
                let next_i = this.r_id_gen.next();
                node_stack.push([node, id, left_id, next_i]);
                node_stack.push([node.right, next_i, void 8, void 8]);
                node = node.right;
            } else if (left_valid && right_valid) {
                let convert = (node, id) => {
                    if (node.id == '`') {
                        if (node.left.id == '!'|| node.right === '!') {
                            throw 'Application has too few arguments.'
                        }
                        return new ExecCall(id)
                    } else {
                        let ec = AST2Exec[node.id];
                        if (node.id == '.') {
                            return new ec(node.value);
                        } else {
                            return new ec();
                        }
                    }
                }
                let left_v = convert(node.left, left_id);
                let right_v = convert(node.right, right_id);
                this.add_call(id, left_v, right_v);
            }
        }
        return init;
    }
    add_call (id, v1, v2) {
        this.seq.set(id, [v1, v2]);
    }
    run (buf) {
        for (let i of this.inits) this.run_s(buf, i);
    }
    run_s (buf, init) {
        // arguments are always evaluated in LtR order
        // (when they are in fact evaluated)
        // we keep track of the evaluation as a callstack state.
        // i think we could instead drop a function with ExecCall()s in it
        // and add a new one with ExecValue()s
        const EVAL_NONE = 0;
        const EVAL_LEFT = 1;
        const EVAL_RIGHT = 2;
        let id; let eval_state;
        let callstack = new ExecCallStack ([init],[EVAL_NONE]);
        let reg = new ExecRegister ();
        let total = 0;
        while (callstack.length > 0 || this.stop) {
            console.log(callstack+'');
            [id, eval_state] = callstack.pop()
            if (total++ > 600) break;
            // to obj or whatever
            let k = 0;
            console.log('>', callstack.length, id.id, this.seq.toStringW(id));
            let f0 = this.seq.get(id);
            let new_calls = new ExecCallStack ();
            // we unshift when creating calls because we want them
            // to evaluate in the same order (normally FILO)
            // that they are created (FIFO)
            const create_call = (val1, val2, t1=EVAL_NONE) => {
                let new_id = this.r_id_gen.next();
                this.add_call(new_id, val1, val2);
                new_calls.unshift(new_id, t1);
                return new ExecValue(new_id);
            }
            // this calls the function an ExecCall points to
            // and then calls the caller again with updated state
            const push_call = (id1, id2, state) => {
                new_calls.unshift(id2, EVAL_NONE);
                new_calls.unshift(id1, state);
            }
            const deref = (id) => {
                let r = reg.get(id.id);
                // ExecValues can be unwrapped arbitrarily
                // tho ExecCalls cannot
                while (r instanceof ExecValue) {
                    r = reg.get(r.id.id);
                }
                return r;
            }
            let leftValued = f0[0] instanceof ExecValue;
            let rightValued = f0[1] instanceof ExecValue;
            let leftCall = f0[0] instanceof ExecCall;
            let rightCall = f0[1] instanceof ExecCall;
            // we could do a whole new call but its possible
            // to just dereference here and move on
            let f;
            if (leftValued && rightValued
                || leftCall && rightCall && eval_state == EVAL_RIGHT) {
                //reg[id.id] = create_call(deref(f[0]), deref(f[1]));
                f = [deref(f0[0]), deref(f0[1])];
            } else if (leftValued || leftCall && (eval_state == EVAL_LEFT
                || eval_state == EVAL_RIGHT)) {
                f = [deref(f0[0]), f0[1]];
            } else if (rightValued || rightCall && eval_state == EVAL_RIGHT) {
                f = [f0[0], deref(f0[1])];
            } else {
                f = [f0[0], f0[1]];
            }
            if (f[0] instanceof ExecCall && f[1] instanceof ExecCall 
                && eval_state == EVAL_RIGHT) {
                // idk how the hell we could end up here.
                // an ExecCall would have to end up in the register
                // that maybe should be a fatal error
                let val1 = deref(f[0]);
                let val2 = deref(f[0]);
                reg.set(id, create_call(val, f[1], EVAL_NONE));
            } else if (f[0] instanceof ExecCall) {
                if (eval_state == EVAL_RIGHT || eval_state == EVAL_RIGHT) {
                    let val = deref(f[0]);
                    reg.set(id, create_call(val, f[1], EVAL_NONE));
                } else {
                    push_call(id, f[0].id, EVAL_LEFT);
                }
            } else if (f[1] instanceof ExecCall) {
                if (eval_state == EVAL_RIGHT) {
                    let val = deref(f[1]);
                    reg.set(id, create_call(f[0], f[1], EVAL_RIGHT));
                } else if (f[0] instanceof ExecDelay) {
                    // don't execute anything
                    reg.set(id, new ExecPromise(f[1]));
                } else {
                    push_call(id, f[1].id, EVAL_RIGHT);
                }
            } else if (f[0] instanceof ExecChar) {
                buf.push(f[0].value); // write character
                reg.set(id, f[1]);
            } else if (f[0] instanceof ExecIdentity) {
                reg.set(id, f[1]);
            } else if (f[0] instanceof ExecConstant) {
                reg.set(id, new ExecConstant1(f[1]));
            } else if (f[0] instanceof ExecConstant1) {
                reg.set(id, f[0].value);
            } else if (f[0] instanceof ExecSubstitute) {
                reg.set(id, new ExecSubstitute1(f[1]));
            } else if (f[0] instanceof ExecSubstitute1) {
                reg.set(id, new ExecSubstitute2(f[0].x, f[1]));
            } else if (f[0] instanceof ExecSubstitute2) {
                let id1 = create_call(f[0].x, f[1]);
                let id2 = create_call(f[0].y, f[1]);
                reg.set(id, create_call(id1, id2, EVAL_RIGHT));
            } else if (f[0] instanceof ExecCallCC) {
                let continuation = callstack.clone();
                reg.set(id, create_call(f[1], new ExecCC(id,continuation)));
            } else if (f[0] instanceof ExecCC) {
                console.log('cc', f[0].id, ''+f[1]);
                reg.set(f[0].id, f[1]);
                callstack = f[0].continuation.clone();
            } else if (f[0] instanceof ExecDelay) {
                reg.set(id, f[1]);
            } else if (f[0] instanceof ExecPromise) {
                reg.set(id, create_call(f[0].value, f[1], EVAL_NONE));
            } else if (f[0] instanceof ExecExit) {
                callstack = new ExecCallStack ();
            } else {
                throw 'Execution error: '+f[0]+" not supported.\n"
                    +"Call at p"+id+": "+f[0]+" "+f[1]+"\n"
                    +callstack;
            }
            callstack.append(new_calls);
            console.log(reg.map.size, id.id, [...this.seq.map.keys()].map((k)=>
                id.id == k ? '['+(reg.map.get(k)||'<>')+']' : ''+(reg.map.get(k)||'<>')
            ).join(', '));
        }
    }
    toString () {
        return this.seq+'';
    }
}

window.onload = () => {
let parser = new Unlambda ();
const code_pad = document.getElementById('code');
const run_button = document.getElementById('run');
const stop_button = document.getElementById('stop');
const parse_place = document.getElementById('parse');
const executable_place = document.getElementById('executable');
const output_place = document.getElementById('output');
const error_place = document.getElementById('error');
let exec;
run_button.addEventListener('click', (e) => {
    let code_source = code_pad.value;
    parse_place.innerText = '';
    output_place.innerText = '';
    error_place.innerText = '';
    try {
        let ast = parser.parse(code_source);
        parse_place.innerText = ''+ast;
        exec = ast.compile();
        executable_place.innerText = ''+exec;
        let buf = new class {
            push (arg) {
                output_place.append(arg);
            }
        }();
        exec.run(buf);
    } catch (e) {
        console.error(e);
        error_place.innerText = ''+e;
    }
});
stop_button.addEventListener('click', (e) => {
    exec.stop = true;
});
}
</script>
</head>
<body>
<div class=main_container>
<textarea id=code cols=100 rows=25></textarea>
<span class=right>
<input type=button value=run id=run
/><input type=button value=stop id=stop /><br>
<b>AST: </b><span id=parse></span>
<b>ASM: </b><span id=executable></span>
<b>Out: </b><span id=output></span>
<b>Err: </b><span id=error></span>
</span>
</div>
</body>
</html>