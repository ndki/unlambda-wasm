<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<style>
.main_container {
    display: flex;
}
.right {
    vertical-align: top;
    display: inline-block;
    font-family: sans-serif;
    font-size: 12px;
    white-space: pre-wrap;
}
</style>
<script>
'use strict;'
const Unlambda = class {
    parse (source) {
        let ast = new UnlambdaAST ();
        let node_stack = [ast.top];
        const READ = 0;
        const CHAR = 1;
        const CMMT = 2;
        let state = READ;
        let node = new UnlambdaASTNode ();
        for (let c of source) {
            if (state == READ && c.match(/\S/)) {
                const char_map = {
                    '`': UnlambdaASTApply,
                    'e': UnlambdaASTExit,
                    's': UnlambdaASTSubstitute,
                    'k': UnlambdaASTConstant,
                    'i': UnlambdaASTIdentity,
                    'v': UnlambdaASTVoid,
                    'd': UnlambdaASTDelay,
                    'c': UnlambdaASTCallCC,
                    '@': UnlambdaASTRead,
                    '|': UnlambdaASTReprint,
                };
                let type = char_map[c];
                if (type === undefined) {
                    if (c == '.') {
                        node = new UnlambdaASTChar ();
                        state = CHAR;
                    } else if (c == 'r') {
                        node = new UnlambdaASTChar ();
                        node.value = "\n";
                    } else if (c == '?') {
                        node = new UnlambdaASTCompare ();
                        state = CHAR;
                    } else if (c == '#') {
                        state = CMMT;
                    } else {
                        throw 'Parse error: Unrecognized character '+c+'.'
                    }
                } else {
                    node = new char_map[c] ();
                }
                if (node.id != '!') {
                    let next = node_stack.pop().add(node);
                    if (next !== undefined) node_stack.push(...next);
                }
            } else if (state == CHAR) {
                node.value = c;
                state = READ;
            } else if (state == CMMT) {
                if (c == "\n") state = READ;
            }
        }
        return ast;
    }
    run () {
    }
}
const UnlambdaAST = class {
    top;
    constructor () {
        this.top = new UnlambdaASTTop ();
    }
    toString () {
        return ''+this.top;
    }
    compile () {
        return new UnlambdaExecutable (this);
    }
}
const UnlambdaASTNode = class {
    get name () { return 'empty' }
    get data () { return false }
    get id () { return '!' }
    static toString () {
        return '[empty]';
    }
    toString () {
        return '['+this.name+']';
    }
}
const UnlambdaASTTop = class {
    get name () { return 'top' }
    get data () { return true }
    list = [];
    add (node) {
        this.list.push(node);
        if (node.data) {
            return [this, node];
        } else {
            return [this];
        }
    }
    toString () {
        return 'AST(' + this.list.join(', ') + ')';
    }
}
const UnlambdaASTApply = class extends UnlambdaASTNode {
    get name () { return 'apply' }
    get data () { return true }
    get id () { return '`' }
    left = new UnlambdaASTNode ();
    right = new UnlambdaASTNode ();
    add (node) {
        if (this.left.id == '!') {
            this.left = node;
            if (node.data) {
                return [this, node];
            } else {
                return [this];
            }
        } else if (this.right.id == '!') {
            this.right = node;
            if (node.data) {
                return [node];
            } else {
                return [];
            }
        } else {
            throw 'Internal parser error: Full apply added to.';
        }
    }
    toString () {
        //return '`(' + this.left + ' ' + this.right + ')';
        let str = '`(';
        let rights = ['', this.right];
        let v = this.left;
        while (rights.length > 0) {
            if (v.id == '`') {
                str += '`('
                if (v.left.id == '`') {
                    rights.push(v.right);
                    v = v.left;
                } else {
                    str += v.left + ', ';
                    if (v.right.id == '`') {
                        rights.push('');
                        v = v.right;
                    } else {
                        str += v.right + ')';
                        v = rights.pop();
                    }
                }
            } else {
                str += ', '+v+')';
                v = rights.pop();
            }
        }
        str += ')';
        return str;
    }
}
const UnlambdaASTConstant = class extends UnlambdaASTNode {
    get name () { return 'const' }
    get id () { return 'k' }
}
const UnlambdaASTSubstitute = class extends UnlambdaASTNode {
    get name () { return 'sub' }
    get id () { return 's' }
}
const UnlambdaASTIdentity = class extends UnlambdaASTNode {
    get name () { return 'id' }
    get id () { return 'i' }
}
const UnlambdaASTVoid = class extends UnlambdaASTNode {
    get name () { return 'void' }
    get id () { return 'v' }
}
const UnlambdaASTCallCC = class extends UnlambdaASTNode {
    get name () { return 'call/cc' }
    get id () { return 'c' }
}
const UnlambdaASTDelay = class extends UnlambdaASTNode {
    get name () { return 'delay' }
    get id () { return 'd' }
}
const UnlambdaASTExit = class extends UnlambdaASTNode {
    get name () { return 'exit' }
    get id () { return 'e' }
}
const UnlambdaASTChar = class extends UnlambdaASTNode {
    get name () { return 'char' }
    get id () { return '.' }
    value = '';
    toString () {
        return '[char ' + this.value + ']';
    }
}
const UnlambdaASTRead = class extends UnlambdaASTNode {
    get name () { return 'read' }
    get id () { return '@' }
}
const UnlambdaASTCompare = class extends UnlambdaASTNode {
    get name () { return 'cmp' }
    get id () { return '?' }
    value = '';
    toString () {
        return '[cmp ' + this.value + ']';
    }
}
const UnlambdaASTReprint = class extends UnlambdaASTNode {
    get name () { return 'reprint' }
    get id () { return '|' }
}

// okay here's where its less obvious whats going on...
// we compile to a state machine and each state is
// a function application called ExecData.
// we very frequently add states.
// when they are no longer referenced.
// there are only a few types of function (ExecNode):
// one of the symbol-functions,
// the special ExecResolve function,
// or one of the 4 pointer-functions,
// ExecValue, ExecCall, and ExecContinuation.
// we say an ExecNode "resolves" to an immediately callable function,
// and an ExecData "resolves" by producing an ExecData
// that is an immediately callable function.
// an ExecCall pointer-function cannot be resolved, that is,
// we define an ExecData to be unresolved if contains an ExecCall,
// or it is some `dP, where P is an ExecCall.
// however, an unresolved Data will be used to generate resolved Data
// using the other 4 functions.
// the ExecVariable special function resolves to the value of 
// the last function application. it is our single internal variable.
// however, this variable never stores anything other than
// the pointer to some valued ExecData.
// an ExecValue pointer-function resolves to its target.
// that is, its value is the resolved ExecData that it pointer addresses.
// although a function with ExecValues is resolved, the resulting value
// may have to be generated as an additional state.
// an ExecContinuation pointer-function encodes a continuation.
// a continuation is identity-valued but causes the state machine
// to move to a particular state.
// an ExecNext pointer-function encodes the callstack. it calls
// its argument on the ExecVariable, and then calls a continuation
// on that result, as long as its argument isn't Exit.
// Exit is actually just any continuation that addresses
// the special state, `eX (exit with current value).
// EDIT: "current character" is also an internal variable, going
// by other implementations. its not obvious to me that this should
// be true and preferred but whatever.
const ExecNode = class {
    toString () { return this.id }
    get id () { return '!' }
}
const ExecPtr = class {
    ptr;
    constructor (ptr) { this.ptr = ptr }
    toString () { return '['+this.ptr+']' }
    [Symbol.toPrimitive] (hint) {
        if (hint == 'string') {
            return this.toString();
        } else {
            return this.ptr;
        }
    }
}
const EXIT = new ExecPtr(0);
const ExecPtrNode = class {
    ptr; is_exit;
    constructor (ptr) {
        this.ptr = ptr;
        this.is_exit = ptr.id == EXIT;
    }
    toString () { return this.id + this.ptr.toString() }
}
const ExecValue = class extends ExecPtrNode {
    get id () { return 'V' }
}
const ExecCall = class extends ExecPtrNode {
    get id () { return 'P' }
}
const ExecContinuation = class extends ExecPtrNode {
    get id () { return 'Q' }
}
const ExecNext = class extends ExecPtrNode {
    get id () { return 'N' }
}
const ExecVariable = class extends ExecNode {
    get id () { return 'X' }
}
const ExecVoid = class extends ExecNode {
    get id () { return 'v' }
}
const ExecIdentity = class extends ExecNode {
    get id () { return 'i' }
}
const ExecDelay = class extends ExecNode {
    get id () { return 'd' }
}
const ExecConstant = class extends ExecNode {
    get id () { return 'k' }
}
const ExecSubstitute = class extends ExecNode {
    get id () { return 's' }
}
const ExecCallCC = class extends ExecNode {
    get id () { return 'c' }
}
const ExecChar = class extends ExecNode {
    get id () { return '.' }
    constructor (v) { super(); this.value = v }
    toString () { return "'"+this.value+"'" }
}
const ExecRead = class extends ExecNode {
    get id () { return '@' }
}
const ExecCompare = class extends ExecNode {
    get id () { return '?' }
    constructor (v) { super(); this.value = v }
    toString () { return "'"+this.value+"'" }
}
const ExecReprint = class extends ExecNode {
    get id () { return '|' }
}

const ExecData = class {
    left; right;
    constructor (x,y) { this.left = x; this.right = y }
    toString () { return this.id+'<'+this.left+' '+this.right+'>'; }
}
// Some data but it has a P or two
const ExecCallData = class extends ExecData {
    get id () { return 'C' }
    toString () { return '<'+this.left+' '+this.right+'>'; }
}
// Some data that can be evaluated
const ExecResolvedData = class extends ExecData {
    get id () { return 'O' }
    toString () { return this.left+'('+this.right+')'; }
}
// Some continuation data
const ExecNextData = class extends ExecData {
    get id () { return '&' }
    toString () { return 'N('+this.left.ptr + ', ' +this.right.ptr+')'; }
}
// Some value
const ExecIdentityData = class extends ExecData {
    get id () { return 'I' }
    constructor (v) { super(new ExecIdentity(), v) }
    toString () { return 'i'+this.right; }
}
// Some `kx
const ExecConstantData = class extends ExecData {
    get id () { return 'K' }
    constructor (v) { super(new ExecConstant (), v )}
    toString () { return 'k'+this.right; }
}
// Some `sx
const ExecSubstituteData = class extends ExecData {
    get id () { return 'S' }
    constructor (x) { super(new ExecSubstitute (),x ) }
    toString () { return 's'+this.right; }
}
// Some ``sxy
const ExecSubstituteData2 = class extends ExecData {
    get id () { return 'Z' }
    toString () { return 's('+this.left+','+this.right+')' }
}
// Some `dx
const ExecPromiseData = class extends ExecData {
    get id () { return 'D' }
    constructor (v) { super(new ExecDelay (), v) }
    toString () { return 'd'+this.right; }
}
// Some `vx
const ExecVoidData = class extends ExecData {
    get id () { return 'V' }
    constructor () { super() }
    toString () { return 'v' }
}

const ExecAddrGen = class {
    i = EXIT.ptr+1;
    next () { return new ExecPtr (this.i++) }
}

const ExecRunningStates = class {
    map = new Map (); static_map;
    constructor (states) { this.static_map = states.map }
    set ({ptr: a}, b) {
        //console.log('states <- '+b);
        return this.map.set(a, b);
    }
    get ({ptr: a}) {
        return this.map.get(a) || this.static_map.get(a);
    }
    size () {
        return this.map.size;
    }
}
const ExecStates = class {
    map;
    constructor (map = new Map ()) { this.map = map }
    set ({ptr: a}, b) {
        //console.log('states <- '+b);
        return this.map.set(a, b)
    }
    get ({ptr: a}) { return this.map.get(a) }
    clone () {
        return new ExecStates(new Map (this.map));
    }
    size () {
        return this.map.size;
    }
    toString () {
        let s = [...this.map.values()].join(', ');
        return s;
    }
    debugString (id) {
        let s = [...this.map.keys()].map((k) =>{
            return id.ptr == k ? '['+this.map.get(k)+']' : this.map.get(k)
        }).join(', ');
        return s;
    }
}

const AST2Exec = {
    '.': ExecChar,
    'k': ExecConstant,
    'i': ExecIdentity,
    'v': ExecVoid,
    'd': ExecDelay,
    'c': ExecCallCC,
    's': ExecSubstitute,
    'e': ExecContinuation,
    '@': ExecRead,
    '?': ExecCompare,
    '|': ExecReprint,
};

const UnlambdaExecutable = class {
    states;
    inits;
    addr_gen;
    constructor (ast) {
        this.compile(ast);
    }
    compile (ast) {
        this.states = new ExecStates ();
        this.addr_gen = new ExecAddrGen ();
        this.inits = [];
        for (let node of ast.top.list) {
            if (node instanceof UnlambdaASTApply) {
                this.inits.push(this.compile_node(node));
            }
        }
    }
    compile_node (node) {
        let ptr = this.addr_gen.next();
        let init = void 8;
        let node_stack = [[node, ptr, void 8, void 8]];
        let left_ptr; let right_ptr;
        while (node_stack.length > 0) {
            [node, ptr, left_ptr, right_ptr] = node_stack.pop();
            let left_valid = node.left.id != '!';
            let right_valid = node.right.id != '!';
            let left_apply = node.left.id == '`';
            let right_apply = node.right.id == '`';
            if (!init && left_valid && right_valid) {
                init = ptr;
            }
            if (left_apply && left_ptr === undefined){
                let next_i = this.addr_gen.next();
                node_stack.push([node, ptr, next_i, void 8]);
                node_stack.push([node.left, next_i, void 8, void 8]);
                node = node.left;
            } else if (right_apply && right_ptr === undefined){
                let next_i = this.addr_gen.next();
                node_stack.push([node, ptr, left_ptr, next_i]);
                node_stack.push([node.right, next_i, void 8, void 8]);
                node = node.right;
            } else if (left_valid && right_valid) {
                let convert = (node, ptr) => {
                    if (node.id == '`') {
                        if (node.left.id == '!'|| node.right === '!') {
                            throw 'Application has too few arguments.'
                        }
                        return new ExecCall(ptr)
                    } else {
                        let ec = AST2Exec[node.id];
                        if (node.id == '.' || node.id == '?') {
                            return new ec(node.value);
                        } else if (node.id == 'e') {
                            return new ec(EXIT);
                        } else {
                            return new ec();
                        }
                    }
                }
                let left_v = convert(node.left, left_ptr);
                let right_v = convert(node.right, right_ptr);
                this.states.set(ptr, new ExecCallData(left_v, right_v));
            }
        }
        return init;
    }
    run (input, output) {
        return this.inits.map((init)=>this.run_s(input, output, init));
    }
    run_s (input, output, init) {
        let ptr = init;
        let variable = new ExecContinuation (EXIT);
        let trail = EXIT;
        let current_char = new ExecVoid ();
        let states = new ExecRunningStates(this.states);
        let total = 0;
        while (ptr != EXIT && total++ < 600000) {
            //console.log(ptr+' '+variable+' >>', states.debugString(ptr));
            let data = states.get(ptr);
            let {left, right} = data;
            //console.log(ptr+' '+variable+' >> '+data);
            const add_state = (s) => {
                let new_addr = this.addr_gen.next();
                states.set(new_addr, s);
                return new_addr;
            }
            if (left.id == 'X') { left = variable }
            else if (right.id == 'X') { right = variable }
            if (left.id == 'P') {
                let new_d = new ExecResolvedData(new ExecVariable(), right);
                let replacement = add_state(new_d);
                let continuation = new ExecContinuation(replacement);
                let next = new ExecNext(trail);
                trail = add_state(new ExecNextData(next, continuation));
                ptr = left.ptr;
            } else if (left.id == 'd') {
                variable = new ExecValue(add_state(new ExecPromiseData(right)));
                ptr = trail;
            } else if (right.id == 'P') {
                let new_d = new ExecResolvedData(left, new ExecVariable());
                let replacement = add_state(new_d);
                let continuation = new ExecContinuation(replacement);
                let next = new ExecNext(trail);
                trail = add_state(new ExecNextData(next, continuation));
                ptr = right.ptr;
            } else if (left.id == 'V') {
                let v = states.get(left.ptr);
                switch (v.id) {
                    case 'I':
                    ptr = add_state(new ExecResolvedData(v.right, right));
                    break;
                    case 'D':
                    ptr = add_state(new ExecCallData(v.right, right));
                    break;
                    case 'K':
                    ptr = add_state(new ExecResolvedData(v.right, right));
                    break;
                    case 'S':
                    let z = add_state(new ExecSubstituteData2(v.right, right));
                    variable = new ExecValue(z);
                    ptr = trail;
                    break;
                    case 'Z':
                        let left_d = new ExecResolvedData(v.left, right);
                        let right_d = new ExecResolvedData(v.right, right);
                        let left_ptr = new ExecCall(add_state(left_d));
                        let right_ptr = new ExecCall(add_state(right_d));
                        let ap_d = new ExecCallData(left_ptr, right_ptr);
                        let replacement = add_state(ap_d);
                        ptr = replacement;
                    break;
                    case 'O':
                    throw 'Something fucked up idk'
                    case 'C':
                    throw 'Something fucked up idk'
                    default:
                    throw 'Something fucked up idk'
                }
            } else if (data.id == '&') {
                trail = left.ptr;
                ptr = right.ptr;
            } else if (data.id == 'I') {
                variable = right;
                ptr = trail;
            } else if (data.id == 'C' || data.id == 'O') {
                switch (left.id) {
                    case '.':
                    output.push(left.value);
                    variable = new ExecValue(add_state(new ExecIdentityData(right)));
                    ptr = trail;
                    break;
                    case 'i':
                    variable = new ExecValue(add_state(new ExecIdentityData(right)));
                    ptr = trail;
                    break;
                    case 'k':
                    variable = new ExecValue(add_state(new ExecConstantData(right)));
                    ptr = trail;
                    break;
                    case 's':
                    variable = new ExecValue(add_state(new ExecSubstituteData(right)));
                    ptr = trail;
                    break;
                    case '@':
                    let m = input.next();
                    let read_result;
                    if (!m.done) {
                        read_result = new ExecVoid ();
                    } else {
                        current_char = new ExecChar(m.value);
                        read_result = new ExecIdentity ()
                    }
                    ptr = add_state(new ExecResolvedData(right, read_result));
                    break;
                    case '?':
                    let compare_result
                    if (!current_char || current_char.value != left.value) {
                        compare_result = new ExecVoid ();
                    } else {
                        compare_result = new ExecIdentity ()
                    }
                    ptr = add_state(new ExecResolvedData(right, compare_result));
                    break;
                    case '|':
                    ptr = add_state(new ExecResolvedData(right, current_char));
                    break;
                    case 'Q':
                    variable = right;
                    ptr = left.ptr;
                    break;
                    case 'c':
                    let ic = new ExecResolvedData(right, new ExecContinuation(trail))
                    ptr = add_state(ic);
                    break;
                    case 'v':
                    variable = new ExecVoid();
                    ptr = trail;
                    break;
                    default:
                    throw 'Internal runtime error: '+left+' is not recognized.'
                }
            } else {
                throw 'not sure what to do with '+data
            }
        }
        return [total, states.size()];
    }
    toString () {
        return this.states+'';
    }
}

window.onload = () => {
let parser = new Unlambda ();
const code_pad = document.getElementById('code');
const run_button = document.getElementById('run');
const stop_button = document.getElementById('stop');
const input_place = document.getElementById('input');
const status_place = document.getElementById('status');
const parse_place = document.getElementById('parse');
const executable_place = document.getElementById('executable');
const output_place = document.getElementById('output');
const error_place = document.getElementById('error');
let exec;
run_button.addEventListener('click', (e) => {
    let code_source = code_pad.value;
    status_place.innerText = '';
    parse_place.innerText = '';
    output_place.innerText = '';
    error_place.innerText = '';
    try {
        status_place.append('Parsing.. ');
        let p_t = Date.now();
        let ast = parser.parse(code_source);
        //parse_place.innerText = ''+ast;
        parse_place.innerText = 'Parsed in '+(Date.now()-p_t)/1000+'s.';
        let c_t = Date.now();
        status_place.append('Compiling.. ');
        exec = ast.compile();
        //executable_place.innerText = ''+exec;
        executable_place.innerText = 'Compiled in '+(Date.now()-c_t)/1000+'s'
            + ' to size ' + exec.states.size()+'.';
        let output = new class {
            push (arg) {
                output_place.append(arg);
            }
        }();
        let input = new class {
            next (arg) {
                //input_place.enable();
                //input_place.disable();
                let next = input_place.value[0];
                input_place.value = input_place.value.slice(1);
                return { done: !!next, value: next };
            }
        }();
        status_place.append('Running.. ');
        let r_t = Date.now();
        let results = exec.run(input, output);
        status_place.append('Done. Ran in '+(Date.now()-r_t)/1000
            +'s with ['+
            results.map(([total,size])=>'iter '+total+', size '+size).join('; ')
            +'].');
    } catch (e) {
        console.error(e);
        error_place.innerText = ''+e;
    }
});
stop_button.addEventListener('click', (e) => {
    exec.stop = true;
});
}
</script>
</head>
<body>
<div class=main_container>
<textarea id=code cols=100 rows=25></textarea>
<span class=right>
<input type=button value=run id=run
/><input type=button value=stop id=stop />
Input: <input type=text id=input />
<br>
<b>Status: </b><span id=status></span>
<b>AST: </b><span id=parse></span>
<b>ASM: </b><span id=executable></span>
<b>Out: </b><span id=output></span>
<b>Err: </b><span id=error></span>
</span>
</div>
</body>
</html>